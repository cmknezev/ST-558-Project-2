---
title: "ST 558 Project 2 Report"
author: "Collin Knezevich & Jiyue Zhang"
date: '2022-07-02'
output: html_document
---

```{r}
# Libraries 
library(tidyverse)
library(caret)
library(randomForest)
library(gbm)
```

# Introduction 

# Data 

We will read in the online news popularity data set locally. 
```{r}
newsData <- read_csv("OnlineNewsPopularity/OnlineNewsPopularity.csv")
```

For our initial analysis, we will only consider data from a single data channel. We will consider the "bus" (business) data channel, and we will subset the data to focus on this channel. 
```{r}
busNews <- newsData %>% filter(data_channel_is_bus == 1) 
```

# Summarizations 
## Summary Statistics
Our response variable of interest for this analysis is the number of shares. First, we will quickly summarize the distribution of the shares variable. 
```{r}
summary(busNews$shares)
sd(busNews$shares)
```
Here, we can see the mean number of shares, as well as the five number summary (min, 1st quartile, median, 3rd quartile, max). From the value of mean and median, since the mean is bigger than themedian, the distribution of shares will be right-skewed. And the standard deviation is really large, so there might be some outliers in the data. 

## Graphs densityplot
Let us continue by creating a density plot to show the distribution of the number of shares. 
```{r}
ggplot(data = busNews, aes(x = shares)) + 
  geom_density(color = "darkgreen") + 
  labs(title = "Distribution of Shares", x = "# Shares")
```
This density plot allows us to analyze the distribuion of the number of shares. We can look for any skewness in the distribution, the number of peaks, and the overall shape of the distribution.

## Graphs barplot
We would like to compare the proportion of articles that are shared a greater number of times than the median number of shares, for articles that are published on a weekend day or not. We will create a new variable, equal to 1 if the article was shared a greater number of times than the median, and equal to 0 otherwise. 
```{r}
md <- median(busNews$shares)
busNews2 <- busNews %>% mutate(shares_gt_median = ifelse(shares > md, 1, 0)) 

ggplot(data = busNews2, aes(x = as.factor(is_weekend))) + 
  geom_bar(aes(fill = as.factor(shares_gt_median)), position = "fill") + 
  labs(title = "Proportion of Articles Shared More Than the Median, 
       for Published on Weekend vs. Not", x = "Weekend", y = "Proportion", 
       fill = "Shares > Median") + 
  scale_x_discrete(labels = c('No', 'Yes')) + 
  scale_fill_discrete(labels = c('No', 'Yes'))
```
We can easily compare the difference between articles published on the weekend and articles published on weekdays. 

## Graphs Scatterplot1
Now, we would like to investigate the relationship between the number of shares and the polarity of the title (`title_sentiment_polarity`). We will create a scatterplot to show this relationship. 
```{r}
ggplot(data = busNews, aes(x = title_sentiment_polarity, y = shares)) + 
  geom_point() + 
  geom_smooth(method = lm, color = "blue") + 
  labs(title = "Title Polarity v. Number of Shares", x = "Title Polarity", 
       y = "# Shares")
```
This chart will give us insight into the linear relationship between the polarity of the title and the number of shares. If the line slopes upwards, we can expect that the number of shares increases as the polarity of the title increases. If the line sloped downwards, we can expect the opposite. 

## Graphs Scatterplot2
Now, we would like to investigate the relationship between the number of shares and the Text sentiment polarity(`global_sentiment_polarity`). We will create a scatterplot to show this relationship. 
```{r}
ggplot(data = busNews, aes(x = global_sentiment_polarity, y = shares)) + 
  geom_point() + 
  geom_smooth(method = lm, color = "blue") + 
  labs(title = "Text_sentiment_Polarity v. Number of Shares", x = "Text Polarity", 
       y = "# Shares")
```
This chart will give us insight into the linear relationship between the polarity of the text and the number of shares. If the line slopes upwards, we can expect that the number of shares increases as the polarity of the title increases. If the line sloped downwards, we can expect the opposite.

## Graphs Scatterplot3
Now, we would like to investigate the relationship between the number of shares and the Avg. polarity of positive words(`avg_positive_polarity`). We will create a scatterplot to show this relationship. 
```{r}
ggplot(data = busNews, aes(x = avg_positive_polarity, y = shares)) + 
  geom_point() + 
  geom_smooth(method = lm, color = "blue") + 
  labs(title = "Positive Polarity v. Number of Shares", x = "Positive Polarity", 
       y = "# Shares")
```
This chart will give us insight into the linear relationship between the polarity of the text and the number of shares. If the line slopes upwards, we can expect that the number of shares increases as the polarity of the title increases. If the line sloped downwards, we can expect the opposite.

## Graphs Scatterplot4
Now, we would like to investigate the relationship between the number of shares and the Avg. polarity of negative words(`avg_negative_polarity`). We will create a scatterplot to show this relationship. 
```{r}
ggplot(data = busNews, aes(x = avg_negative_polarity, y = shares)) + 
  geom_point() + 
  geom_smooth(method = lm, color = "blue") + 
  labs(title = "Negative Polarity v. Number of Shares", x = "Negative Polarity", 
       y = "# Shares")
```
This chart will give us insight into the linear relationship between the Avg. polarity of negative words and the number of shares. If the line slopes upwards, we can expect that the number of shares increases as the polarity of the title increases. If the line sloped downwards, we can expect the opposite.


# Modeling 

First, in order to prepare our data for modeling/prediction, we will remove two variables from the dataset that are non-predictive variables (`url` and `timedelta`). We will then split the data into training and test sets (70% and 30%, respectively).   
```{r}
busNews <- busNews %>% select(-c(url, timedelta))

# set seed for reproducibility 
set.seed(55)

# creating training and test sets 
newsIndex <- createDataPartition(busNews$shares, p = 0.7, list = FALSE)
newsTrain <- busNews[newsIndex, ] 
newsTest <- busNews[-newsIndex, ]
```

First, we will create a few linear regression models. Linear regression is a type of supervised learning that allows us to easily make predictions on our response variable of interest (in this case, number of shares). The goal of linear regression is to build an equation that takes in all specified predictor variables in order to best predict the response variable. The coefficients associated with the predictor variables for the equation are chosen such that the sum of squared residuals is minimized (i.e., minimizing prediction errors).   

The first linear regression model we will fit in order to predict the number of shares will take in a number of predictor variables pertaining to the subjectivity, polarity, and positivity/negativity of the article. 
```{r}
linModel1 <- lm(shares ~ global_subjectivity + global_sentiment_polarity + 
                  global_rate_positive_words + global_rate_negative_words + 
                  avg_positive_polarity + avg_negative_polarity + 
                  title_subjectivity + title_sentiment_polarity, 
                data = newsTrain)
```

Next, we will create a random forest model. The idea of a random forest model is similar to the idea of a bagged tree model, where we fit many different models on different re-samples of the data, and average all predictions from these models. However when creating a random forest model, we use a random selection of predictor variables for each model created during bootstrapping. Using a random forest model will produce more accurate predictions, and will reduce variance in the model. For our model, we will randomly select m = p/3 predictor variables during boostrapping, where p is the total number of candidate predictor variables. Additionally, we will fit a total of 200 tree models during the boostrapping process.  
```{r}
m <- (ncol(newsTrain) - 1)/3 

rfModel <- randomForest(shares ~ ., data = newsTrain, mtry = m, 
                        ntree = 200, importance = TRUE)
```

Then, we will have a boosted tree model
```{r}
n.trees <- c(25, 50, 100, 150, 200) 
interaction.depth <- c(1, 2, 3, 4)
shrinkage <- 0.1
n.minobsinnode <- 10
gbmFit <- train(shares ~ ., data = newsTrain,
                method = "gbm",
                    verbose=F,
                    trControl = trainControl(method = "repeatedcv",    
                                             number = 5, 
                                             repeats = 3),
                    tuneGrid = expand.grid("n.trees" = n.trees, 
                                           "interaction.depth" = interaction.depth, 
                                           "shrinkage" = shrinkage, 
                                           "n.minobsinnode" = n.minobsinnode))
```
